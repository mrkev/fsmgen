<html>
<head>
  <meta charset="UTF-8">
  <title>Made by Kevin</title>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
  <style>
    body { font-family: "Open Sans"; }
    svg { margin: 20px; background-color: #eee; }
    rect.bar { fill: #4169e1; }
    text.label {
      fill: #888;
      font-size: x-small;
      dominant-baseline: middle;
      text-anchor: middle;
    }
    circle.node {
      fill: green;
      opacity: 0.3;
    }
    line.link {
      stroke: black;
      opacity: 0.3;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pegjs/0.9.0/peg.min.js"></script>
  <script src="http://mdaines.github.io/viz.js/bower_components/viz.js/viz.js"></script>
  <script src="http://d3js.org/d3.v3.min.js"></script>
</head>
<body>
  
  <script>
  'use strict';
  /**
   * Utility functions.
   */

   /** Applies styles in an object to a d3 element */
  var apply_style = function (acc, obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      return acc.style(key, obj[key]);
    }, acc);
  };

  /** d3 canvas -> Options object -> appended d3 element */
  window.appended_to = function (svg) {
    return function (obj) {
      return Object.keys(obj).reduce(function (acc, key) {
        if (key == 'append') return acc;
        if (key == 'call')   return acc.call(obj[key]);
        if (key == 'text')   return acc.text(obj[key]);
        if (key == 'style')  return apply_style(acc, obj[key]);
        return acc.attr(key, obj[key]);
      }, svg.append(obj.append));
    };
  };

  Array.ofsize = function(size) {
    return Array.apply(null, Array(size));
  };

  Array.prototype.sum = function () {
    return this.reduce(function (acc, x) { return acc + x; }, 0);
  };

  let concat = (a, b) => a.concat(b);
  Array.prototype.dedup = function (comp) {
    return this.filter((x, i) => this.find(x, comp) === i)
  }

  /** Replacement for indexOf, with optional custom comparator */
  Array.prototype.find = function (o, comp) {
    comp = comp || ((x, y) => x === y);
    for (var i = 0; i < this.length; i++) {
        if (comp(o, this[i])) return i;
    }
    return -1;
  };

  Array.prototype.subsetOf = function(arr, comp) {
    return this.filter((x) => arr.find(x, comp) < 0).length === 0;
  };
  Array.prototype.each = function(cb) {
    this.forEach(cb); return this;
  };


  </script>

<button id="parse_button">Parse</button>
<textarea name="fsm_src" id="fsm_src" cols="30" rows="10">
initial state q_0
  | 0 -> q_0
  | 1 -> q_1

state q_1
</textarea>
<div id="d3out"></div>
<div id="svg-wrapper"></div>
<select>
  <option value="circo">circo</option>
  <option value="dot">dot</option>
  <option value="fdp">fdp</option>
  <option value="neato">neato</option>
  <option value="osage">osage</option>
  <option value="twopi">twopi</option>
</select>

<select>
  <option value="svg">svg</option>
  <option value="svg">svg</option>
</select>

<button id="download_button">Download</button>


  <script src="typecheck.js"></script>

  <script>
  "use strict";
  /* global console */

  var parser = null;

  /** Generate parser */
  d3.text("fsm_parser.pegjs", function(err, diff) {

    if (err) return document.write("Error reading parser");

    parser = PEG.buildParser(diff);

  });

  
  d3.select("#parse_button").on('click', () => {

    let engine = "dot";

    Promise
    .resolve (d3.select("#fsm_src").node().value)
    .then    ((src) => parser.parse(src))
    .catch   ((err) => alert(err))
    .then    ((asa) => typecheck(asa)) // abstract syntax array
    .then    ((asa) => generate_dot(asa))
    .then    ((dot) => render_dot(engine, dot))
    .catch   ((err) => {
      if (err instanceof TypeError) {
        alert(err.message);
      }
      else {
        console.log(err.message);
        console.trace(err);
      }
    })

  });

  function generate_dot (nodes) {
    let node_defs = nodes
      .map(node => node.id.string +
          ((node.type === "initial") ? " [peripheries=2]" : ""))
      .join("\n");

    let edge_defs = nodes
      .map(node => node.edges)
      .reduce(concat, [])
      .map(edge => edge.source.string + " -> " + 
                   edge.target.string + 
                 ' [label="' + edge.symbol.string + '"]')
      .join("\n");

    return "digraph { \n" +
      node_defs + "\n" +
      edge_defs + "\n" +
    "}"
  }

  function render_dot (engine, dot) {

    let result = Viz(dot, { format:"svg", engine:engine });
    var newsvg = document.getElementById("svg-wrapper");

    newsvg.innerHTML = result;

  }

  </script>
</body>
</html>